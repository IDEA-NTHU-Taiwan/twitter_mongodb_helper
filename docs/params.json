{
  "name": "Twitter MongoDB ",
  "tagline": "A collection of python scripts for dealing with mongoDB indexes, aggregation pipleline and map-reduce",
  "body": "# Twitter MongoDB helper functions\r\n\r\nA collection of python functions for dealing with mongoDB indexes, aggregation pipleline and map-reduce\r\n\r\n# MongoDB Indexing\r\n\r\nIt is essential to create indexes on your fields in order to speed of the run time of your queries. A few ideal indexes will be outlined below but ultimately it will depend on your data needs.\r\n\r\n## Resources\r\n\r\n- [Text Search](https://docs.mongodb.com/manual/text-search/)\r\n- [Create Text Index](https://docs.mongodb.com/manual/core/index-text/#create-a-text-index)\r\n- [Multi-Key Indexes](https://docs.mongodb.com/manual/core/index-multikey/)\r\n- [Compound Prefix](https://docs.mongodb.com/manual/core/index-compound/#compound-index-prefix)\r\n- [Multi-Key Indexes](https://docs.mongodb.com/manual/core/index-multikey/)\r\n- [Manging Indexes](https://docs.mongodb.com/v3.2/tutorial/manage-indexes/)\r\n\r\n## Instructions\r\n\r\nThis assumes that you already have MongoDB installed and running and already populated with tweets.\r\n\r\nStart the mongo shell from the terminal and select your databse\r\n\r\n```bash\r\nmongo\r\nuse twitterdb\r\n```\r\n\r\n## Creating a text index\r\n\r\n```bash\r\ndb.tweets.createIndex(\r\n  {text: \"text\",\"entities.hashtags.text\": \"text\"},\r\n  {background:true}\r\n)\r\n```\r\n\r\nThis allows for \"Google search\" like capability on the hashtags and the text of the tweet itself. Only one text index can exist at a time. [See Text search link above]\r\n\r\n```bash\r\ndb.tweets.find({$text:{$search: \"java shop coffee\"}})\r\n```\r\n\r\n## Creating a compound index\r\n\r\n```bash\r\ndb.tweets.createIndex(\r\n  {\r\n    \"user.id\": 1,\r\n    \"user.statuses_count\": 1,\r\n    \"user.followers_count\": 1,\r\n    \"user.location\":1, \"user.lang\": 1\r\n  },\r\n  {background:true}\r\n)\r\n```\r\n\r\n## Creating a single field index\r\n\r\n```bash\r\ndb.tweets.createIndex({timestamp_ms: 1}, {background: true})\r\ndb.tweets.createIndex({lang: 1}, {background:true})\r\ndb.tweets.createIndex({\"entities.user_mentions\": 1}, {background: true})\r\ndb.tweets.createIndex({\"entities.urls\": 1}, {background: true})\r\ndb.tweets.createIndex({\"user.location\": 1}, {background:true})\r\ndb.tweets.createIndex({\"user.id_str\": 1}, {background:true})\r\n```\r\n\r\n## Insights\r\n\r\n- Aggregation is orders of magnitude faster than map reduce\r\n- Queries that scan the full database may time out when executed at the application level (PyMongo etc). If this happens try running them from Mongo Shell instead\r\n\r\n## Aggregation vs MapReduce\r\n\r\nGet an aggregate count of all the hashtags in a collection, filtered by English. (uses mongo shell)\r\n\r\n```bash\r\ndb.tweets.aggregate(\r\n  [\r\n    {$match: {\"lang\": {$in: [\"en\"]}}},\r\n    {$project: {\"entities.hashtags\": 1, _id: 0}},\r\n    {$unwind: \"$entities.hashtags\"},\r\n    {$group: {_id: \"$entities.hashtags.text\", count: {$sum: 1}}},\r\n    {$sort: {count: -1}},\r\n    {$project: {\"hashtag\": \"$_id\", \"count\": 1, \"_id\": 0}},\r\n    {$out: \"hashtag_dist_en\"}\r\n  ]\r\n)\r\n```\r\n\r\nSame query with MapReduce (Pymongo)\r\n\r\n```python\r\ndef hashtag_map_reduce(client, db_name, subset, output_name):\r\n    map_function = Code(\"function () {\"\r\n                        \"    var hashtags = this.entities.hashtags;\"\r\n                        \"    for (var i = 0; i < hashtags.length; i ++){\"\r\n                        \"        if (hashtags[i].text.length > 0) {\"\r\n                        \"            emit (hashtags[i].text, 1);\"\r\n                        \"        }\"\r\n                        \"    }\"\r\n                        \"}\")\r\n\r\n    reduce_function = Code(\"function (keyHashtag, occurs) {\"\r\n                           \"     return Array.sum(occurs);\"\r\n                           \"}\")\r\n    dbo = client[db_name]\r\n    cursor = dbo[subset].map_reduce(\r\n        map_function, reduce_function, output_name, query={\"lang\": {\"$eq\": \"en\"}})\r\n```\r\n\r\nAggregate user mentions, same structure as the above\r\n\r\n```bash\r\ndb.tweets.aggregate(\r\n  [\r\n    {$match: {\"lang\": {$in: [\"en\"]}}},\r\n    {$project: {\"entities.user_mentions\": 1, _id: 0}},\r\n    {$unwind: \"$entities.user_mentions\"},\r\n    {$group: {_id: {id_str: \"$entities.user_mentions.id_str\",\r\n             \"screen_name\": \"$entities.user_mentions.screen_name\"},\r\n             count: {$sum: 1}}},\r\n    {$project: {id_str: \"$_id.id_str\", \"screen_name\": \"$_id.screen_name\",   \r\n               \"count\": 1, \"_id\": 0}},\r\n    {$sort: {count: -1}},\r\n    { $out : \"user_mentions_dist_en\" }\r\n  ]\r\n)\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}